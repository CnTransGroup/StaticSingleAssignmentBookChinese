# 第二章 性质和变体
回忆第一章，如果每个变量只被定义一次，且每个用到这个变量的地方都是指向它的定义点，那么我们说该程序从属SSA形式。SSA有很多种变体和特色，它们都有考量。举个例子，不同形式的SSA就φ函数参数个数来说不尽相同。一些变体可能更难构造、维护和解构。本章将探索这些SSA变体，并讨论它们在某些确定的上下文中的优点。

## 2.1 Def-use和use-def链
SSA形式的每个变量只被定义一次。Def-use链是一种数据结构，它将变量的定义（def）和所有使用（use）这个变量的集合关联起来。反过来的use-def链是指能到达使用这个变量的所有定义。在本书后面我们会提到，def-use链对于前向数据流分析（forward data-flow analysis）很有用，因为它缩短了生成和使用数据流信息的程序点的距离。

因为每个变量仅定义一次的性质，SSA形式在很多方面简化了def-use和use-def链。**首先**，SSA形式尽可能早的组合信息。请看下图
![](fig/fig2-1.png)

非SSA形式的def-use需要很多次数据合并等，因为多次用到x，而基于SSA的def-use可以高效合并。

**其次**，因为关联变量和它的定义点很简单，所以use-def链的表达和维护几乎是无开销的。如果程序是SSA形式的，变量的use-def链自动存在，这些链构成链所谓的SSA图（见第12章）。显式包含use-def链简化了一些后向传播算法，比如死代码消除优化。

由于def-use是use-def的完全逆转体，基于它可以很容易的实现一些前向传播算法，维护这个只需要付出很小的努力。然而，就算没有def-use链，一些比较轻量级的前向传播算法如拷贝折叠也是可以实现的：使用单pass来沿着CFG的拓扑顺序遍历，大多数def都在use之前。当处理一个操作时，use-def链让我们可以从中间访问一个前面计算过的值。保守的合并动作仅发生在循环头的φ函数遇到没有处理的参数的时候。这样一个轻量级传播已经被证明是相当高效的。

## 2.2 最简性
SSA的构造包括两个阶段：重命名变量，放置φ函数。第一个阶段的目标是为了满足单个定义可达的性质，这一点早已提到过。最简性是φ插入后产生的一个额外属性，第三章会详细描述经典SSA构造算法，这一章我们主要描述SSA的最简性。

假设变量v的定义为D，程序点为p，在CFG中如果存在一条从D达到p的路径，且这条路径没有发生v的其它定义，那么我们称D到达（reach）程序点p。另外，当且仅当代码中的所有程序点的每个变量都只有一个定义可达，我们称这个程序具有单达到定义属性（single reaching-definition property）。在满足了单到达定义属性后，最简性意味着插入尽可能少的φ函数。

这个特性也可以用下面的join集合符号表达。令n1和n2表示两个不同的CFG的基本块，存在一个基本块n3，这里是否和n1和n2相同不重要，如果存在至少两个非空的路径n1到n3以及n2到n3（所谓非空是指至少包含一条CFG边），那么我们说n1和n2在n3处交汇，n3出现在两条路径中。换句话说，两条路径仅在n3交汇。令S表示基本块集合，如果S中至少两个基本块在n3交汇，那么n3 join这些基本块。S的join集用符号J(S)表达。

直觉上，join集对应φ函数。换句话说，如果n1和n2两个基本块都包含变量v的定义，那么我们应该在所有J({n1,n2})基本块里面放置φ函数。我们再规范一下这句话，如果Dv是包含v变量的基本块的集合，那么φ函数应该被放置在J(Dv)表示的所有基本块中。由于φ函数本身也算是def，所以在J(Dv U J(Dv))处我们可能还要插入些新的φ函数。事实证明J(S U J(S))=J(S)，所以join集合就表示应该在哪插入φ函数的最简集合。

目前我们不知道有任何优化严格要求最简性。然而只在join集放置φ函数可以很容易的使用第四章4.4中提到的拓扑遍历来完成，它是一个经典的技术。在后面我们还会提到使用它的一些原因。最后，正如未来会在第三章3.3针对可归约流图（reducible flow graph）中解释的那样，一些拷贝传播算法可以很容易的将非最简SSA转化为最简SSA。

## 2.3 严格SSA形式和支配属性

